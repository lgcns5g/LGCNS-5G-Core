diff --git a/.dockerignore b/.dockerignore
index 738a20d..b464872 100644
--- a/.dockerignore
+++ b/.dockerignore
@@ -1,7 +1,6 @@
 **/*.md
 **/docker-compose*.yml
 **/docker-compose*.yaml
-**/Dockerfile*
 .git
 .dockerignore
 .cache
diff --git a/lib/core/ogs-log.c b/lib/core/ogs-log.c
index 5baf385..de579fe 100644
--- a/lib/core/ogs-log.c
+++ b/lib/core/ogs-log.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "core-config-private.h"
@@ -86,7 +88,7 @@ typedef struct ogs_log_domain_s {
 
 const char *level_strings[] = {
     NULL,
-    "FATAL", "ERROR", "WARNING", "INFO", "DEBUG", "TRACE",
+    "FATAL", "ERROR", "WARNING", "INFO", "MESSAGE", "DEBUG", "TRACE",
 };
 
 static OGS_POOL(log_pool, ogs_log_t);
@@ -349,6 +351,7 @@ static ogs_log_level_e ogs_log_level_from_string(const char *string)
     else if (!strcasecmp(string, "error")) level = OGS_LOG_ERROR;
     else if (!strcasecmp(string, "warn")) level = OGS_LOG_WARN;
     else if (!strcasecmp(string, "info")) level = OGS_LOG_INFO;
+    else if (!strcasecmp(string, "message")) level = OGS_LOG_MESSAGE;
     else if (!strcasecmp(string, "debug")) level = OGS_LOG_DEBUG;
     else if (!strcasecmp(string, "trace")) level = OGS_LOG_TRACE;
 
@@ -364,7 +367,7 @@ int ogs_log_config_domain(const char *domain, const char *level)
             l = ogs_log_level_from_string(level);
             if (l == OGS_ERROR) {
                 ogs_error("Invalid LOG-LEVEL "
-                        "[none:fatal|error|warn|info|debug|trace]: %s\n",
+                        "[none:fatal|error|warn|info|message|debug|trace]: %s\n",
                         level);
                 return OGS_ERROR;
             }
@@ -573,7 +576,8 @@ static char *log_level(char *buf, char *last,
     const char *colors[] = {
         TA_NOR,
         TA_FGC_BOLD_RED, TA_FGC_BOLD_YELLOW, TA_FGC_BOLD_CYAN,
-        TA_FGC_BOLD_GREEN, TA_FGC_BOLD_WHITE, TA_FGC_WHITE,
+        TA_FGC_BOLD_GREEN, TA_FGC_BOLD_BLUE, TA_FGC_BOLD_WHITE, 
+        TA_FGC_WHITE,
     };
 
     buf = ogs_slprintf(buf, last, "%s%s%s: ",
diff --git a/lib/core/ogs-log.h b/lib/core/ogs-log.h
index 24a6b77..79b2d12 100644
--- a/lib/core/ogs-log.h
+++ b/lib/core/ogs-log.h
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #if !defined(OGS_CORE_INSIDE) && !defined(OGS_CORE_COMPILATION)
@@ -36,6 +38,7 @@ extern "C" {
 #define ogs_error(...) ogs_log_message(OGS_LOG_ERROR, 0, __VA_ARGS__)
 #define ogs_warn(...) ogs_log_message(OGS_LOG_WARN, 0, __VA_ARGS__)
 #define ogs_info(...) ogs_log_message(OGS_LOG_INFO, 0, __VA_ARGS__)
+#define ogs_message(...) ogs_log_message(OGS_LOG_MESSAGE, 0, __VA_ARGS__)
 #define ogs_debug(...) ogs_log_message(OGS_LOG_DEBUG, 0, __VA_ARGS__)
 #define ogs_trace(...) ogs_log_message(OGS_LOG_TRACE, 0, __VA_ARGS__)
 
@@ -58,6 +61,7 @@ typedef enum {
     OGS_LOG_ERROR,
     OGS_LOG_WARN,
     OGS_LOG_INFO,
+    OGS_LOG_MESSAGE,
     OGS_LOG_DEBUG,
     OGS_LOG_TRACE,
     OGS_LOG_DEFAULT = OGS_LOG_INFO,
diff --git a/lib/dbi/subscription.c b/lib/dbi/subscription.c
index 4f7f081..7889b52 100644
--- a/lib/dbi/subscription.c
+++ b/lib/dbi/subscription.c
@@ -385,6 +385,11 @@ int ogs_dbi_subscription_data(char *supi,
             subscription_data->imsi =
                 ogs_strndup(utf8, ogs_min(length, OGS_MAX_IMSI_BCD_LEN) + 1);
             ogs_assert(subscription_data->imsi);
+        } else if (!strcmp(key, "imeisv") &&
+            BSON_ITER_HOLDS_UTF8(&iter)) {
+            utf8 = bson_iter_utf8(&iter, &length);
+            subscription_data->pei =
+                ogs_strndup(utf8, ogs_min(length, OGS_MAX_IMEISV_BCD_LEN) + 1);
         } else if (!strcmp(key, "access_restriction_data") &&
             BSON_ITER_HOLDS_INT32(&iter)) {
             subscription_data->access_restriction_data =
diff --git a/lib/pfcp/handler.c b/lib/pfcp/handler.c
index 356bd81..3133272 100644
--- a/lib/pfcp/handler.c
+++ b/lib/pfcp/handler.c
@@ -150,6 +150,9 @@ bool ogs_pfcp_cp_handle_association_setup_response(
     ogs_assert(node);
     ogs_assert(rsp);
 
+    char buf[OGS_ADDRSTRLEN];
+    ogs_message("[upf: %s] PFCPAssociationSetupResponse", OGS_ADDR(&xact->node->addr, buf));
+
     ogs_gtpu_resource_remove_all(&node->gtpu_resource_list);
 
     for (i = 0; i < OGS_MAX_NUM_OF_GTPU_RESOURCE; i++) {
diff --git a/lib/pfcp/path.c b/lib/pfcp/path.c
index 8719afd..d8290f3 100644
--- a/lib/pfcp/path.c
+++ b/lib/pfcp/path.c
@@ -240,6 +240,11 @@ int ogs_pfcp_cp_send_association_setup_request(ogs_pfcp_node_t *node,
     rv = ogs_pfcp_xact_commit(xact);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        char buf[OGS_ADDRSTRLEN];
+        ogs_message("[upf: %s] PFCPAssociationSetupRequest", OGS_ADDR(&xact->node->addr, buf));
+    }
+
     return rv;
 }
 
diff --git a/lib/proto/types.h b/lib/proto/types.h
index b05626a..919041b 100644
--- a/lib/proto/types.h
+++ b/lib/proto/types.h
@@ -698,6 +698,7 @@ typedef struct ogs_subscription_data_s {
     ogs_slice_data_t slice[OGS_MAX_NUM_OF_SLICE];
 
     char *imsi;
+    char *pei;
 
 #define OGS_MAX_NUM_OF_MSISDN                                   2
     int num_of_msisdn;
diff --git a/lib/sbi/ogs-sbi.h b/lib/sbi/ogs-sbi.h
index f5430b2..cce262f 100644
--- a/lib/sbi/ogs-sbi.h
+++ b/lib/sbi/ogs-sbi.h
@@ -28,6 +28,8 @@
 #pragma GCC diagnostic ignored "-Wstrict-prototypes"
 #endif
 
+#define OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING 1
+
 #include "model/nf_profile.h"
 #include "model/nf_group_cond.h"
 #include "model/smf_info.h"
diff --git a/src/amf/amf-sm.h b/src/amf/amf-sm.h
index 5cd19c0..b760f31 100644
--- a/src/amf/amf-sm.h
+++ b/src/amf/amf-sm.h
@@ -21,6 +21,7 @@
 #define AMF_SM_H
 
 #include "event.h"
+#include "log.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/src/amf/context.c b/src/amf/context.c
index ad5260a..88a60c0 100644
--- a/src/amf/context.c
+++ b/src/amf/context.c
@@ -18,6 +18,7 @@
  */
 
 #include "ngap-path.h"
+#include "log.h"
 
 static amf_context_t self;
 
@@ -1569,6 +1570,8 @@ void amf_ue_remove(amf_ue_t *amf_ue)
 
     ogs_assert(amf_ue);
 
+    amf_log_rm_state(amf_ue->suci, RM_NULL);
+
     ogs_list_remove(&self.amf_ue_list, amf_ue);
 
     amf_ue_fsm_fini(amf_ue);
diff --git a/src/amf/context.h b/src/amf/context.h
index e95db3d..da5c721 100644
--- a/src/amf/context.h
+++ b/src/amf/context.h
@@ -29,6 +29,7 @@
 #include "amf-sm.h"
 #include "timer.h"
 #include "metrics.h"
+#include "log.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -303,6 +304,12 @@ struct amf_ue_s {
     ((__aMF)->security_context_available == 1) && \
      ((__aMF)->mac_failed == 0) && \
      ((__aMF)->nas.ue.ksi != OGS_NAS_KSI_NO_KEY_IS_AVAILABLE))
+#define CLEAR_SECURITY_CONTEXT(__aMF) \
+    do { \
+        ogs_assert((__aMF)); \
+        (__aMF)->security_context_available = 0; \
+        (__aMF)->mac_failed = 0; \
+    } while(0)
     int             security_context_available;
     int             mac_failed;
 
diff --git a/src/amf/gmm-handler.c b/src/amf/gmm-handler.c
index 50b4c1e..eb647a9 100644
--- a/src/amf/gmm-handler.c
+++ b/src/amf/gmm-handler.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "nas-security.h"
@@ -50,6 +52,8 @@ ogs_nas_5gmm_cause_t gmm_handle_registration_request(amf_ue_t *amf_ue,
     ogs_nas_ue_security_capability_t *ue_security_capability = NULL;
     ogs_nas_5gs_guti_t nas_guti;
 
+    char *suci, *supi = NULL;
+
     ogs_assert(amf_ue);
     ran_ue = ran_ue_cycle(amf_ue->ran_ue);
     ogs_assert(ran_ue);
@@ -62,6 +66,20 @@ ogs_nas_5gmm_cause_t gmm_handle_registration_request(amf_ue_t *amf_ue,
     ue_security_capability = &registration_request->ue_security_capability;
     ogs_assert(ue_security_capability);
 
+    if (AMF_UE_HAVE_SUCI(amf_ue)) {
+        amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_REQUEST, amf_ue->supi);
+    } else {
+        suci = ogs_nas_5gs_suci_from_mobile_identity(&registration_request->mobile_identity);
+        if (suci) {
+            supi = ogs_supi_from_supi_or_suci(suci);
+            amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_REQUEST, supi);
+            ogs_free(supi);           
+        } else {
+            amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_REQUEST, NULL);
+        }
+        ogs_free(suci);
+    }
+
     /*
      * TS33.501
      * Ch 6.4.6. Protection of initial NAS message
@@ -759,6 +777,8 @@ int gmm_handle_deregistration_request(amf_ue_t *amf_ue,
     ogs_assert(amf_ue);
     ogs_assert(deregistration_request);
 
+    amf_log_nas_message(OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE, amf_ue->supi);
+
     de_registration_type = &deregistration_request->de_registration_type;
 
     /* Set 5GS De-registration Type */
@@ -1079,6 +1099,8 @@ int gmm_handle_ul_nas_transport(amf_ue_t *amf_ue,
         gsm_header = (ogs_nas_5gsm_header_t *)payload_container->buffer;
         ogs_assert(gsm_header);
 
+        amf_log_nas_message(gsm_header->message_type, amf_ue->supi);
+        
         if (gsm_header->message_type ==
                 OGS_NAS_5GS_PDU_SESSION_ESTABLISHMENT_REQUEST) {
             sess = amf_sess_find_by_psi(amf_ue, *pdu_session_id);
diff --git a/src/amf/gmm-sm.c b/src/amf/gmm-sm.c
index 71a25c6..0dcda08 100644
--- a/src/amf/gmm-sm.c
+++ b/src/amf/gmm-sm.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "ngap-handler.h"
@@ -29,6 +31,7 @@
 #include "npcf-handler.h"
 #include "sbi-path.h"
 #include "amf-sm.h"
+#include "log.h"
 
 #undef OGS_LOG_DOMAIN
 #define OGS_LOG_DOMAIN __gmm_log_domain
@@ -137,6 +140,7 @@ void gmm_state_de_registered(ogs_fsm_t *s, amf_event_t *e)
                         "Stop retransmission");
                 CLEAR_AMF_UE_TIMER(amf_ue->t3570);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3570.retry_count++;
                 r = nas_5gs_send_identity_request(amf_ue);
@@ -152,6 +156,7 @@ void gmm_state_de_registered(ogs_fsm_t *s, amf_event_t *e)
                         "Stop retransmission");
                 CLEAR_AMF_UE_TIMER(amf_ue->t3522);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3522.retry_count++;
                 r = nas_5gs_send_de_registration_request(amf_ue,
@@ -521,6 +526,7 @@ void gmm_state_registered(ogs_fsm_t *s, amf_event_t *e)
                         "Stop retransmission");
                 CLEAR_AMF_UE_TIMER(amf_ue->t3522);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3522.retry_count++;
                 r = nas_5gs_send_de_registration_request(amf_ue,
@@ -558,6 +564,7 @@ void gmm_state_registered(ogs_fsm_t *s, amf_event_t *e)
                         "Stop retransmission");
                 CLEAR_AMF_UE_TIMER(amf_ue->t3570);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3570.retry_count++;
                 r = nas_5gs_send_identity_request(amf_ue);
@@ -898,6 +905,7 @@ void gmm_state_registered(ogs_fsm_t *s, amf_event_t *e)
                         ogs_warn("[%s] Implicit De-registered", amf_ue->supi);
                         OGS_FSM_TRAN(&amf_ue->sm,
                                 &gmm_state_ue_context_will_remove);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
 
                     } else if (state ==
                             AMF_NETWORK_INITIATED_EXPLICIT_DE_REGISTERED) {
@@ -1011,6 +1019,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1033,6 +1042,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(s, gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
 
@@ -1042,6 +1052,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                         ogs_error("No Allowed-NSSAI");
 
                         OGS_FSM_TRAN(s, gmm_state_exception);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                         break;
                     }
 
@@ -1054,6 +1065,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                         ogs_expect(r == OGS_OK);
                         ogs_assert(r != OGS_ERROR);
                         OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                         break;
                     }
 
@@ -1063,11 +1075,13 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                     ogs_assert(r != OGS_ERROR);
                 }
 
-                if (amf_ue->next.m_tmsi)
+                if (amf_ue->next.m_tmsi) {
                     OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
-                else
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
+                } else {
                     OGS_FSM_TRAN(s, &gmm_state_registered);
-
+                    amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
+                }
             } else {
 
                 amf_sbi_send_release_all_sessions(
@@ -1084,11 +1098,13 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 }
 
                 OGS_FSM_TRAN(s, &gmm_state_authentication);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             }
             break;
 
         case OGS_NAS_5GS_SERVICE_REQUEST:
             ogs_info("Service request");
+            amf_log_nas_message(OGS_NAS_5GS_SERVICE_REQUEST, amf_ue->supi);
 
             if (state != GMM_COMMON_STATE_REGISTERED) {
                 ogs_info("[%s] Handling service request failed [Not registered]",
@@ -1098,6 +1114,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1110,6 +1127,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1120,6 +1138,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1130,6 +1149,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1142,10 +1162,12 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
             OGS_FSM_TRAN(s, gmm_state_registered);
+            amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
             break;
 
         case OGS_NAS_5GS_IDENTITY_RESPONSE:
@@ -1157,12 +1179,14 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
             if (rv != OGS_OK) {
                 ogs_error("gmm_handle_identity_response() failed");
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
             if (!AMF_UE_HAVE_SUCI(amf_ue)) {
                 ogs_error("No SUCI");
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1180,12 +1204,14 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
             }
 
             OGS_FSM_TRAN(s, &gmm_state_authentication);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_5GMM_STATUS:
             ogs_warn("[%s] 5GMM STATUS : Cause[%d]", amf_ue->suci,
                     nas_message->gmm.gmm_status.gmm_cause);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
@@ -1194,10 +1220,13 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
             gmm_handle_deregistration_request(
                     amf_ue, &nas_message->gmm.deregistration_request_from_ue);
             OGS_FSM_TRAN(s, &gmm_state_de_registered);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_DEREGISTRATION_ACCEPT_TO_UE:
             ogs_info("[%s] Deregistration accept", amf_ue->supi);
+            amf_log_nas_message(OGS_NAS_5GS_DEREGISTRATION_ACCEPT_TO_UE, amf_ue->supi);
+
             CLEAR_AMF_UE_TIMER(amf_ue->t3522);
 
             amf_ue->explict_de_registered.n1_done = true;
@@ -1250,6 +1279,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
             if (!h.integrity_protected || !SECURITY_CONTEXT_IS_VALID(amf_ue)) {
                 ogs_error("No Security Context");
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1260,6 +1290,7 @@ static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
         case OGS_NAS_5GS_REGISTRATION_COMPLETE:
             ogs_error("[%s] Registration complete in INVALID-STATE",
                         amf_ue->supi);
+            amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_COMPLETE, amf_ue->supi);
             break;
 
         default:
@@ -1325,6 +1356,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             }
             break;
 
@@ -1389,6 +1421,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
             ogs_expect(r == OGS_OK);
             ogs_assert(r != OGS_ERROR);
             OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
 
             break;
         case OGS_NAS_5GS_REGISTRATION_REQUEST:
@@ -1403,6 +1436,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1417,6 +1451,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
             ogs_warn("[%s] 5GMM STATUS : Cause[%d]",
                     amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
@@ -1425,6 +1460,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
             gmm_handle_deregistration_request(
                     amf_ue, &nas_message->gmm.deregistration_request_from_ue);
             OGS_FSM_TRAN(s, &gmm_state_de_registered);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         default:
@@ -1443,6 +1479,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3560.retry_count++;
                 r = nas_5gs_send_authentication_request(amf_ue);
@@ -1480,6 +1517,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
 
@@ -1494,6 +1532,7 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                         ogs_expect(r == OGS_OK);
                         ogs_assert(r != OGS_ERROR);
                         OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     }
                     break;
                 CASE(OGS_SBI_HTTP_METHOD_PUT)
@@ -1506,8 +1545,10 @@ void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
                         ogs_expect(r == OGS_OK);
                         ogs_assert(r != OGS_ERROR);
                         OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     } else {
                         OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     }
                     break;
                 DEFAULT
@@ -1594,7 +1635,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(amf_ue)) {
-                ogs_warn("[%s] No Security Context", amf_ue->supi);
+                ogs_error("[%s] No Security Context", amf_ue->supi);
                 break;
             }
 
@@ -1610,6 +1651,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1627,9 +1669,11 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
 
             if (amf_ue->nas.message_type == OGS_NAS_5GS_REGISTRATION_REQUEST) {
                 OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else if (amf_ue->nas.message_type ==
                         OGS_NAS_5GS_SERVICE_REQUEST) {
                 OGS_FSM_TRAN(s, &gmm_state_registered);
+                amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
             } else {
                 ogs_fatal("Invalid OGS_NAS_5GS[%d]", amf_ue->nas.message_type);
                 ogs_assert_if_reached();
@@ -1641,6 +1685,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
                     nas_message->gmm.security_mode_reject.gmm_cause);
             CLEAR_AMF_UE_TIMER(amf_ue->t3560);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
         case OGS_NAS_5GS_REGISTRATION_REQUEST:
             ogs_warn("Registration request");
@@ -1654,6 +1699,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -1664,21 +1710,25 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
             ogs_assert(r != OGS_ERROR);
 
             OGS_FSM_TRAN(s, &gmm_state_authentication);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_SERVICE_REQUEST:
             ogs_info("[%s] Service request", amf_ue->supi);
+            amf_log_nas_message(OGS_NAS_5GS_SERVICE_REQUEST, amf_ue->supi);
             r = nas_5gs_send_service_reject(amf_ue,
                     OGS_5GMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
             ogs_expect(r == OGS_OK);
             ogs_assert(r != OGS_ERROR);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_5GMM_STATUS:
             ogs_warn("[%s] 5GMM STATUS : Cause[%d]",
                     amf_ue->supi, nas_message->gmm.gmm_status.gmm_cause);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
@@ -1687,6 +1737,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
             gmm_handle_deregistration_request(
                     amf_ue, &nas_message->gmm.deregistration_request_from_ue);
             OGS_FSM_TRAN(s, &gmm_state_de_registered);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         default:
@@ -1705,6 +1756,7 @@ void gmm_state_security_mode(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3560.retry_count++;
                 r = nas_5gs_send_security_mode_command(amf_ue);
@@ -1778,6 +1830,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
 
@@ -1822,6 +1875,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
 
@@ -1835,6 +1889,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
                 break;
@@ -1857,6 +1912,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                         ogs_error("[%s] amf_npcf_am_policy_control"
                                 "_handle_create() failed", amf_ue->supi);
                         OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                         break;
                     }
 
@@ -1881,8 +1937,10 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                     AMF_UE_CLEAR_N2_TRANSFER(
                             amf_ue, pdu_session_resource_setup_request);
 
-                    if (!amf_ue->next.m_tmsi)
+                    if (!amf_ue->next.m_tmsi) {
                         OGS_FSM_TRAN(s, &gmm_state_registered);
+                        amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
+                    }
                     break;
 
                 DEFAULT
@@ -1915,6 +1973,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
         switch (nas_message->gmm.h.message_type) {
         case OGS_NAS_5GS_REGISTRATION_COMPLETE:
             ogs_info("[%s] Registration complete", amf_ue->supi);
+            amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_COMPLETE, amf_ue->supi);
 
             CLEAR_AMF_UE_TIMER(amf_ue->t3550);
 
@@ -1993,6 +2052,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                         amf_ue->nas.registration.value);
             }
             OGS_FSM_TRAN(s, &gmm_state_registered);
+            amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
             break;
 
         case OGS_NAS_5GS_REGISTRATION_REQUEST:
@@ -2007,6 +2067,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -2023,21 +2084,25 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                 ogs_assert(r != OGS_ERROR);
             }
             OGS_FSM_TRAN(s, &gmm_state_authentication);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_SERVICE_REQUEST:
             ogs_info("[%s] Service request", amf_ue->supi);
+            amf_log_nas_message(OGS_NAS_5GS_SERVICE_REQUEST, amf_ue->supi);
             r = nas_5gs_send_service_reject(amf_ue,
                 OGS_5GMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
             ogs_expect(r == OGS_OK);
             ogs_assert(r != OGS_ERROR);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_5GMM_STATUS:
             ogs_warn("[%s] 5GMM STATUS : Cause[%d]",
                     amf_ue->supi, nas_message->gmm.gmm_status.gmm_cause);
             OGS_FSM_TRAN(s, &gmm_state_exception);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
@@ -2046,6 +2111,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
             gmm_handle_deregistration_request(
                     amf_ue, &nas_message->gmm.deregistration_request_from_ue);
             OGS_FSM_TRAN(s, &gmm_state_de_registered);
+            amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             break;
 
         default:
@@ -2061,6 +2127,7 @@ void gmm_state_initial_context_setup(ogs_fsm_t *s, amf_event_t *e)
                 ogs_warn("[%s] Retransmission failed. Stop retransmission",
                         amf_ue->suci);
                 OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             } else {
                 amf_ue->t3550.retry_count++;
                 r = nas_5gs_send_registration_accept(amf_ue);
@@ -2185,6 +2252,7 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                 ogs_expect(r == OGS_OK);
                 ogs_assert(r != OGS_ERROR);
                 OGS_FSM_TRAN(s, gmm_state_exception);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -2195,6 +2263,7 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                 ogs_assert(r != OGS_ERROR);
 
                 OGS_FSM_TRAN(s, &gmm_state_de_registered);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                 break;
             }
 
@@ -2209,6 +2278,7 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
                     OGS_FSM_TRAN(s, gmm_state_exception);
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                     break;
                 }
 
@@ -2228,6 +2298,7 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                         ogs_expect(r == OGS_OK);
                         ogs_assert(r != OGS_ERROR);
                         OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
+                        amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
                         break;
                     }
 
@@ -2237,10 +2308,13 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                     ogs_assert(r != OGS_ERROR);
                 }
 
-                if (amf_ue->next.m_tmsi)
+                if (amf_ue->next.m_tmsi) {
                     OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
-                else
+                    amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
+                } else {
                     OGS_FSM_TRAN(s, &gmm_state_registered);
+                    amf_log_rm_state(amf_ue->suci, RM_REGISTERED);
+                }
 
             } else {
 
@@ -2258,6 +2332,7 @@ void gmm_state_exception(ogs_fsm_t *s, amf_event_t *e)
                 }
 
                 OGS_FSM_TRAN(s, &gmm_state_authentication);
+                amf_log_rm_state(amf_ue->suci, RM_DEREGISTERED);
             }
             break;
 
diff --git a/src/amf/log.c b/src/amf/log.c
new file mode 100644
index 0000000..287be0a
--- /dev/null
+++ b/src/amf/log.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2019-2022 by Sukchan Lee <acetcom@gmail.com>
+ *
+ * This file is part of Open5GS.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-12-04 Description: add lgcns custom log
+ */
+
+#include "log.h"
+
+void amf_log_nas_message(uint8_t message_type, const char* supi)
+{
+    switch (message_type) {
+    case OGS_NAS_5GS_REGISTRATION_REQUEST:
+        ogs_message("[%s] RegistrationRequest", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_REGISTRATION_ACCEPT:
+        ogs_message("[%s] RegistrationAccept", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_REGISTRATION_COMPLETE:
+        ogs_message("[%s] RegistrationComplete", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_REGISTRATION_REJECT:
+        ogs_message("[%s] RegistrationReject", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
+        ogs_message("[%s] DeregistrationRequestFromUe", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_DEREGISTRATION_ACCEPT_FROM_UE:
+        ogs_message("[%s] DeregistrationAcceptFromUe", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_DEREGISTRATION_REQUEST_TO_UE:
+        ogs_message("[%s] DeregistrationRequestToUe", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_DEREGISTRATION_ACCEPT_TO_UE:
+        ogs_message("[%s] DeregistrationAcceptToUe", supi ? supi : "imsi-");
+        break;
+    case OGS_NAS_5GS_SERVICE_REQUEST:
+        ogs_message("[%s] ServiceRequest", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_SERVICE_REJECT:
+        ogs_message("[%s] ServiceReject", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_SERVICE_ACCEPT:
+        ogs_message("[%s] ServiceAccept", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_PDU_SESSION_ESTABLISHMENT_REQUEST:
+        ogs_message("[%s] PduSessionEstablishmentRequest", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_PDU_SESSION_ESTABLISHMENT_ACCEPT:
+        ogs_message("[%s] PduSessionEstablishmentAccept", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_PDU_SESSION_ESTABLISHMENT_REJECT:
+        ogs_message("[%s] PduSessionEstablishmentReject", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_PDU_SESSION_RELEASE_REQUEST:
+        ogs_message("[%s] PduSessionReleaseRequest", supi ? supi : "imsi-");
+        break;    
+    // case OGS_NAS_5GS_PDU_SESSION_RELEASE_REJECT:
+    //     ogs_message("[%s] PduSessionReleaseReject", supi ? supi : "imsi-");
+    //     break;    
+    case OGS_NAS_5GS_PDU_SESSION_RELEASE_COMMAND:
+        ogs_message("[%s] PduSessionReleaseCommand", supi ? supi : "imsi-");
+        break;    
+    case OGS_NAS_5GS_PDU_SESSION_RELEASE_COMPLETE:
+        ogs_message("[%s] PduSessionReleaseComplete", supi ? supi : "imsi-");
+        break;    
+    }
+}
+
+void amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_t procedureCode, 
+        uint32_t gnb_id, const char* supi, bool is_initiating)
+{
+    switch (procedureCode) {
+    case NGAP_ProcedureCode_id_NGSetup:
+        ogs_message("[gNB: %u] NgSetupRequest", gnb_id);
+        break;
+    case NGAP_ProcedureCode_id_HandoverPreparation: 
+        ogs_message("[%s][gNB: %u] HandoverRequired", supi ? supi : "imsi-", gnb_id); //N2 Handover
+        break;
+    case NGAP_ProcedureCode_id_HandoverResourceAllocation: 
+        ogs_message("[%s][gNB: %u] HandoverRequestAcknowledge", supi ? supi : "imsi-", gnb_id); //N2 Handover
+        break;
+    case NGAP_ProcedureCode_id_HandoverNotification: 
+        ogs_message("[%s][gNB: %u] HandoverNotify", supi ? supi : "imsi-", gnb_id); //N2 Handover
+        break;
+    case NGAP_ProcedureCode_id_PathSwitchRequest:
+        ogs_message("[%s][gNB: %u] PathSwitchRequest", supi ? supi : "imsi-", gnb_id); // Xn Handover
+        break;
+    case NGAP_ProcedureCode_id_NGReset:
+        if (is_initiating) {
+            ogs_message("[gNB: %u] NgResetFromGnb", gnb_id);
+        } else {
+            ogs_message("[gNB: %u] NgResetAcknowledgeFromAmf", gnb_id);
+        }
+        break;
+    }
+}
+
+void amf_log_ngap_message_from_amf(NGAP_ProcedureCode_t procedureCode, 
+        uint32_t gnb_id, const char* supi, bool is_initiating)
+{
+    switch (procedureCode) {
+    case NGAP_ProcedureCode_id_NGSetup:
+        ogs_message("[gNB: %u] NgSetupResponse", gnb_id);
+        break;
+    case NGAP_ProcedureCode_id_HandoverPreparation: 
+        ogs_message("[%s][gNB: %u] HandoverCommand", supi ? supi : "imsi-", gnb_id); //N2 Handover
+        break;
+    case NGAP_ProcedureCode_id_HandoverResourceAllocation: 
+        ogs_message("[%s][gNB: %u] HandoverRequest", supi ? supi : "imsi-", gnb_id); //N2 Handover
+        break;
+    case NGAP_ProcedureCode_id_PathSwitchRequest:
+        ogs_message("[%s][gNB: %u] PathSwitchRequestAcknowledge", supi ? supi : "imsi-", gnb_id); // Xn Handover
+        break;
+    case NGAP_ProcedureCode_id_Paging:
+        ogs_message("[%s][gNB: %u] Paging", supi ? supi : "imsi-", gnb_id); // Xn Handover
+        break;
+    case NGAP_ProcedureCode_id_NGReset:
+        if (is_initiating) {
+            ogs_message("[gNB: %u] NgResetFromAmf", gnb_id);
+        } else {
+            ogs_message("[gNB: %u] NgResetAcknowledgeFromGnb", gnb_id);
+        }
+        break;
+    }
+}
+
+void amf_log_rm_state(char *suci, amf_rm_state_e state){
+
+    if (!suci) 
+        return ;
+
+    switch (state) {
+    case RM_NULL:
+        ogs_info("[%s] RM_NULL", suci);
+        break;
+    case RM_DEREGISTERED:
+        ogs_info("[%s] RM_DEREGISTERED", suci);
+        break;
+    case RM_REGISTERED:
+        ogs_info("[%s] RM_REGISTERED", suci);
+        break;
+    }
+}
\ No newline at end of file
diff --git a/src/amf/log.h b/src/amf/log.h
new file mode 100644
index 0000000..dd6deeb
--- /dev/null
+++ b/src/amf/log.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019-2022 by Sukchan Lee <acetcom@gmail.com>
+ *
+ * This file is part of Open5GS.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-12-04 Description: add lgcns custom log
+ */
+
+#ifndef AMF_LOG_H
+#define AMF_LOG_H
+
+#include "ogs-proto.h"
+#include "ogs-ngap.h"
+#include "ogs-nas-5gs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    RM_NULL = 0,
+    RM_DEREGISTERED,
+    RM_REGISTERED,
+} amf_rm_state_e;
+
+void amf_log_nas_message(uint8_t message_type, const char* supi);
+void amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_t procedureCode, 
+        uint32_t gnb_id, const char* supi, bool is_initiating);
+void amf_log_ngap_message_from_amf(NGAP_ProcedureCode_t procedureCode,
+        uint32_t gnb_id, const char* supi, bool is_initiating);
+
+void amf_log_rm_state(char *suci, amf_rm_state_e state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* AMF_LOG_H */
\ No newline at end of file
diff --git a/src/amf/meson.build b/src/amf/meson.build
index 3ec5041..95f1642 100644
--- a/src/amf/meson.build
+++ b/src/amf/meson.build
@@ -17,6 +17,7 @@
 
 libamf_sources = files('''
     metrics.h
+    log.h
 
     context.c
     event.c
@@ -60,6 +61,7 @@ libamf_sources = files('''
 
     init.c
     metrics.c
+    log.c
 '''.split())
 
 libamf = static_library('amf',
diff --git a/src/amf/namf-handler.c b/src/amf/namf-handler.c
index 77a7d44..8a5c0a6 100644
--- a/src/amf/namf-handler.c
+++ b/src/amf/namf-handler.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "namf-handler.h"
@@ -209,6 +211,11 @@ int amf_namf_comm_handle_n1_n2_message_transfer(
                     r = ngap_send_to_ran_ue(ran_ue, ngapbuf);
                     ogs_expect(r == OGS_OK);
                     ogs_assert(r != OGS_ERROR);
+
+                    if (r == OGS_OK) {
+                        amf_log_nas_message(OGS_NAS_5GS_PDU_SESSION_ESTABLISHMENT_ACCEPT, amf_ue->supi);
+                    }   
+                    
                 } else {
                     sess->pdu_session_establishment_accept = ngapbuf;
                 }
diff --git a/src/amf/nas-path.c b/src/amf/nas-path.c
index 4e6dca5..4d43de5 100644
--- a/src/amf/nas-path.c
+++ b/src/amf/nas-path.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "ngap-path.h"
@@ -180,6 +182,9 @@ int nas_5gs_send_registration_accept(amf_ue_t *amf_ue)
         }
     }
 
+    if (rv == OGS_OK) {
+        amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_ACCEPT, amf_ue->supi);
+    }
     return rv;
 }
 
@@ -227,6 +232,10 @@ int nas_5gs_send_registration_reject(
     rv = nas_5gs_send_to_downlink_nas_transport(amf_ue, gmmbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK) {
+        amf_log_nas_message(OGS_NAS_5GS_REGISTRATION_REJECT, amf_ue->supi);
+    }   
+
     return rv;
 }
 
@@ -308,6 +317,10 @@ int nas_5gs_send_service_accept(amf_ue_t *amf_ue)
         }
     }
 
+    if (rv == OGS_OK) {
+        amf_log_nas_message(OGS_NAS_5GS_SERVICE_ACCEPT, amf_ue->supi);
+    }
+
     return rv;
 }
 
@@ -338,6 +351,10 @@ int nas_5gs_send_service_reject(
     rv = nas_5gs_send_to_downlink_nas_transport(amf_ue, gmmbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK) {
+        amf_log_nas_message(OGS_NAS_5GS_SERVICE_REJECT, amf_ue->supi);
+    }
+
     return rv;
 }
 
@@ -375,6 +392,8 @@ int nas_5gs_send_de_registration_accept(amf_ue_t *amf_ue)
             ogs_error("nas_5gs_send_to_downlink_nas_transport() failed");
             return rv;
         }
+
+        amf_log_nas_message(OGS_NAS_5GS_DEREGISTRATION_ACCEPT_FROM_UE, amf_ue->supi);
     }
 
     rv = ngap_send_ran_ue_context_release_command(ran_ue,
@@ -431,6 +450,10 @@ int nas_5gs_send_de_registration_request(
     rv = nas_5gs_send_to_downlink_nas_transport(amf_ue, gmmbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK) {
+        amf_log_nas_message(OGS_NAS_5GS_DEREGISTRATION_REQUEST_TO_UE, amf_ue->supi);
+    }   
+
     return rv;
 }
 
@@ -844,6 +867,11 @@ int nas_send_pdu_session_release_command(amf_sess_t *sess,
 
         rv = nas_5gs_send_to_gnb(amf_ue, ngapbuf);
         ogs_expect(rv == OGS_OK);
+
+        if (rv == OGS_OK) {
+            amf_log_nas_message(OGS_NAS_5GS_PDU_SESSION_RELEASE_COMMAND, amf_ue->supi);
+        }
+
     } else if (gmmbuf) {
         ogs_pkbuf_free(n2smbuf);
         ngapbuf = ngap_build_downlink_nas_transport(
@@ -855,6 +883,11 @@ int nas_send_pdu_session_release_command(amf_sess_t *sess,
 
         rv = nas_5gs_send_to_gnb(amf_ue, ngapbuf);
         ogs_expect(rv == OGS_OK);
+
+        if (rv == OGS_OK) {
+            amf_log_nas_message(OGS_NAS_5GS_PDU_SESSION_RELEASE_COMMAND, amf_ue->supi);
+        }
+
     } else {
         /*
          * TS23.527
diff --git a/src/amf/nausf-handler.c b/src/amf/nausf-handler.c
index 13577e4..d5cd875 100644
--- a/src/amf/nausf-handler.c
+++ b/src/amf/nausf-handler.c
@@ -105,6 +105,9 @@ int amf_nausf_auth_handle_authenticate(
     ogs_ascii_to_hex(AV5G_AKA->autn, strlen(AV5G_AKA->autn),
         amf_ue->autn, sizeof(amf_ue->autn));
 
+    /* Clear Security Context */
+    CLEAR_SECURITY_CONTEXT(amf_ue);
+
     if (amf_ue->nas.amf.ksi < (OGS_NAS_KSI_NO_KEY_IS_AVAILABLE - 1))
         amf_ue->nas.amf.ksi++;
     else
diff --git a/src/amf/ngap-handler.c b/src/amf/ngap-handler.c
index 4d5cba4..a4f7714 100644
--- a/src/amf/ngap-handler.c
+++ b/src/amf/ngap-handler.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "ngap-handler.h"
@@ -178,6 +180,8 @@ void ngap_handle_ng_setup_request(amf_gnb_t *gnb, ogs_ngap_message_t *message)
     ogs_ngap_GNB_ID_to_uint32(&globalGNB_ID->gNB_ID, &gnb_id);
     ogs_debug("    IP[%s] GNB_ID[0x%x]", OGS_ADDR(gnb->sctp.addr, buf), gnb_id);
 
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_NGSetup, gnb_id, NULL, NULL);
+
     if (PagingDRX)
         ogs_debug("    PagingDRX[%ld]", *PagingDRX);
 
@@ -2702,6 +2706,7 @@ void ngap_handle_path_switch_request(
         ogs_assert(r != OGS_ERROR);
         return;
     }
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_PathSwitchRequest, gnb->gnb_id, amf_ue->supi, NULL);
 
     ogs_info("    [OLD] RAN_UE_NGAP_ID[%d] AMF_UE_NGAP_ID[%lld] ",
         ran_ue->ran_ue_ngap_id, (long long)ran_ue->amf_ue_ngap_id);
@@ -3016,6 +3021,7 @@ void ngap_handle_handover_required(
         ogs_assert(r != OGS_ERROR);
         return;
     }
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_HandoverPreparation, gnb->gnb_id, amf_ue->supi, NULL);
 
     if (!HandoverType) {
         ogs_error("No HandoverType");
@@ -3371,6 +3377,7 @@ void ngap_handle_handover_request_ack(
         ogs_assert(r != OGS_ERROR);
         return;
     }
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_HandoverResourceAllocation, gnb->gnb_id, amf_ue->supi, NULL);
 
     ogs_debug("    Source : RAN_UE_NGAP_ID[%d] AMF_UE_NGAP_ID[%lld] ",
         source_ue->ran_ue_ngap_id, (long long)source_ue->amf_ue_ngap_id);
@@ -3963,6 +3970,8 @@ void ngap_handle_handover_notification(
         return;
     }
 
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_HandoverNotification, gnb->gnb_id, amf_ue->supi, NULL);
+
     amf_ue_associate_ran_ue(amf_ue, target_ue);
 
     if (!UserLocationInformation) {
@@ -4279,6 +4288,7 @@ void ngap_handle_ng_reset(
     ogs_assert(NGReset);
 
     ogs_warn("NGReset");
+    amf_log_ngap_message_from_gnb(NGAP_ProcedureCode_id_NGReset, gnb->gnb_id, NULL, true);
 
     for (i = 0; i < NGReset->protocolIEs.list.count; i++) {
         ie = NGReset->protocolIEs.list.array[i];
@@ -4472,6 +4482,10 @@ void ngap_handle_ng_reset(
         ogs_expect(r == OGS_OK);
         ogs_assert(r != OGS_ERROR);
 
+        if (r == OGS_OK){
+            amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_NGReset, gnb->gnb_id, NULL, false);
+        }
+
         /* Clear NG-Reset Ack Buffer */
         gnb->ng_reset_ack = NULL;
         break;
diff --git a/src/amf/ngap-path.c b/src/amf/ngap-path.c
index 4861034..9274add 100644
--- a/src/amf/ngap-path.c
+++ b/src/amf/ngap-path.c
@@ -15,6 +15,8 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-06-28 Description: add log level 'MESSAGE'
  */
 
 #include "ogs-sctp.h"
@@ -273,6 +275,10 @@ int ngap_send_ng_setup_response(amf_gnb_t *gnb)
     rv = ngap_send_to_gnb(gnb, ngap_buffer, NGAP_NON_UE_SIGNALLING);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_NGSetup, gnb->gnb_id, NULL, NULL);
+    }
+
     return rv;
 }
 
@@ -456,6 +462,8 @@ int ngap_send_paging(amf_ue_t *amf_ue)
                         ogs_error("ngap_send_to_gnb() failed");
                         return rv;
                     }
+
+                    amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_Paging, gnb->gnb_id, amf_ue->supi, NULL);
                 }
             }
         }
@@ -521,6 +529,10 @@ int ngap_send_path_switch_ack(amf_sess_t *sess)
     rv = nas_5gs_send_to_gnb(amf_ue, ngapbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_PathSwitchRequest, amf_ue->ran_ue->gnb->gnb_id, amf_ue->supi, NULL);
+    }
+
     return rv;
 }
 
@@ -557,6 +569,10 @@ int ngap_send_handover_request(amf_ue_t *amf_ue)
     rv = ngap_send_to_ran_ue(target_ue, ngapbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_HandoverResourceAllocation, target_ue->gnb->gnb_id, amf_ue->supi, NULL);
+    }
+
     return rv;
 }
 
@@ -612,6 +628,10 @@ int ngap_send_handover_command(amf_ue_t *amf_ue)
     rv = ngap_send_to_ran_ue(source_ue, ngapbuf);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_HandoverPreparation, source_ue->gnb->gnb_id, amf_ue->supi, NULL);
+    }
+
     return rv;
 }
 
@@ -735,5 +755,9 @@ int ngap_send_ng_reset_ack(
     rv = ngap_send_to_gnb(gnb, ngapbuf, NGAP_NON_UE_SIGNALLING);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        amf_log_ngap_message_from_amf(NGAP_ProcedureCode_id_NGReset, gnb->gnb_id, NULL, false);
+    }
+    
     return rv;
 }
diff --git a/src/main.c b/src/main.c
index 329d5b1..31bae14 100644
--- a/src/main.c
+++ b/src/main.c
@@ -100,6 +100,8 @@ int main(int argc, const char *const argv[])
      *
      * Keep the order of starting-up
      */
+    signal(SIGPIPE, SIG_IGN); // Ignore SIGPIPE 
+
     int rv, i, opt;
     ogs_getopt_t options;
     struct {
diff --git a/src/mme/emm-sm.c b/src/mme/emm-sm.c
index 0e34cdf..890833f 100644
--- a/src/mme/emm-sm.c
+++ b/src/mme/emm-sm.c
@@ -612,7 +612,7 @@ static void common_register_state(ogs_fsm_t *s, mme_event_t *e,
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
+                ogs_error("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
                 r = nas_eps_send_service_reject(mme_ue,
                     OGS_NAS_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
                 ogs_expect(r == OGS_OK);
@@ -739,7 +739,7 @@ static void common_register_state(ogs_fsm_t *s, mme_event_t *e,
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
+                ogs_error("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
                 ogs_assert(OGS_OK ==
                     nas_eps_send_service_reject(mme_ue,
                     OGS_NAS_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK));
@@ -953,7 +953,7 @@ void emm_state_authentication(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
+                ogs_error("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
                 ogs_assert(OGS_OK ==
                     nas_eps_send_service_reject(mme_ue,
                     OGS_NAS_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK));
@@ -1074,7 +1074,7 @@ void emm_state_security_mode(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("[%s] No Security Context", mme_ue->imsi_bcd);
+                ogs_error("[%s] No Security Context", mme_ue->imsi_bcd);
                 break;
             }
 
@@ -1153,7 +1153,7 @@ void emm_state_security_mode(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
+                ogs_error("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
                 ogs_assert(OGS_OK ==
                     nas_eps_send_service_reject(mme_ue,
                     OGS_NAS_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK));
@@ -1271,7 +1271,7 @@ void emm_state_initial_context_setup(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("[%s] No Security Context", mme_ue->imsi_bcd);
+                ogs_error("[%s] No Security Context", mme_ue->imsi_bcd);
                 break;
             }
 
@@ -1323,7 +1323,7 @@ void emm_state_initial_context_setup(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("[%s] No Security Context", mme_ue->imsi_bcd);
+                ogs_error("[%s] No Security Context", mme_ue->imsi_bcd);
                 break;
             }
 
@@ -1384,7 +1384,7 @@ void emm_state_initial_context_setup(ogs_fsm_t *s, mme_event_t *e)
             }
 
             if (!SECURITY_CONTEXT_IS_VALID(mme_ue)) {
-                ogs_warn("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
+                ogs_error("No Security Context : IMSI[%s]", mme_ue->imsi_bcd);
                 ogs_assert(OGS_OK ==
                     nas_eps_send_service_reject(mme_ue,
                     OGS_NAS_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK));
diff --git a/src/pcf/context.c b/src/pcf/context.c
index 7545e61..492c598 100644
--- a/src/pcf/context.c
+++ b/src/pcf/context.c
@@ -123,6 +123,16 @@ int pcf_context_parse_config(void)
                     /* handle config in sbi library */
                 } else if (!strcmp(pcf_key, "metrics")) {
                     /* handle config in metrics library */
+                } else if (!strcmp(pcf_key, "imeisv_check")) {
+                    const char *imeisv_check = ogs_yaml_iter_value(&pcf_iter);
+                    bool *enabled = &self.imeisv_check;
+                    if (!strcmp("True", imeisv_check) || 
+                        !strcmp("true", imeisv_check)) {
+                        *enabled = true;
+                    }
+                    else {
+                        *enabled = false;
+                    }
                 } else
                     ogs_warn("unknown key `%s`", pcf_key);
             }
diff --git a/src/pcf/context.h b/src/pcf/context.h
index 0dbd446..bc7ce06 100644
--- a/src/pcf/context.h
+++ b/src/pcf/context.h
@@ -43,6 +43,7 @@ typedef struct pcf_context_s {
 
     ogs_hash_t      *ipv4addr_hash;
     ogs_hash_t      *ipv6prefix_hash;
+    bool            imeisv_check;
 } pcf_context_t;
 
 struct pcf_ue_s {
diff --git a/src/pcf/npcf-handler.c b/src/pcf/npcf-handler.c
index 36e767c..990d982 100644
--- a/src/pcf/npcf-handler.c
+++ b/src/pcf/npcf-handler.c
@@ -124,7 +124,8 @@ bool pcf_npcf_am_policy_contrtol_handle_create(pcf_ue_t *pcf_ue,
         ogs_assert(value);
 
         if (strcmp(type, "imeisv") == 0) {
-            ogs_assert(OGS_OK == ogs_dbi_update_imeisv(pcf_ue->supi, value));
+            if (!pcf_self()->imeisv_check)
+                ogs_assert(OGS_OK == ogs_dbi_update_imeisv(pcf_ue->supi, value));
         } else {
             ogs_fatal("Unknown Type = %s", type);
             ogs_assert_if_reached();
diff --git a/src/pcf/nudr-handler.c b/src/pcf/nudr-handler.c
index 90aeb25..ed61adb 100644
--- a/src/pcf/nudr-handler.c
+++ b/src/pcf/nudr-handler.c
@@ -69,10 +69,17 @@ bool pcf_nudr_dr_handle_query_am_data(
             status = OGS_SBI_HTTP_STATUS_NOT_FOUND;
             goto cleanup;
         }
+        
+        if (pcf_self()->imeisv_check && ogs_strcasecmp(subscription_data.pei, ogs_id_get_value(pcf_ue->pei)) != 0) {
+            strerror = ogs_msprintf("IMEISV verification failed(%s != %s)",
+                ogs_id_get_value(pcf_ue->pei), subscription_data.pei);
+            status = OGS_SBI_HTTP_STATUS_NOT_FOUND;
+            goto cleanup;
+        }
 
         if (!subscription_data.ambr.uplink &&
                 !subscription_data.ambr.downlink) {
-            ogs_error("[%s] No UE-AMBR", pcf_ue->supi);
+            strerror = ogs_msprintf("[%s] No UE-AMBR", pcf_ue->supi);
             status = OGS_SBI_HTTP_STATUS_NOT_FOUND;
             goto cleanup;
         }
diff --git a/src/smf/context.c b/src/smf/context.c
index f4a9b6a..7f0e2a0 100644
--- a/src/smf/context.c
+++ b/src/smf/context.c
@@ -20,6 +20,7 @@
 #include "context.h"
 #include "gtp-path.h"
 #include "pfcp-path.h"
+#include "log.h"
 
 static smf_context_t self;
 static ogs_diam_config_t g_diam_conf;
@@ -2451,6 +2452,10 @@ int smf_bearer_remove(smf_bearer_t *bearer)
 {
     ogs_assert(bearer);
     ogs_assert(bearer->sess);
+    char buf[OGS_ADDRSTRLEN];
+
+    smf_log_session_state(bearer->sess->smf_ue->supi, bearer->qfi, bearer->sess->session.name,
+                        bearer->sess->ipv4 ? OGS_INET_NTOP(&bearer->sess->ipv4->addr, buf) : "", 0);
 
     ogs_list_remove(&bearer->sess->bearer_list, bearer);
 
diff --git a/src/smf/context.h b/src/smf/context.h
index 9fbd98b..784a9f3 100644
--- a/src/smf/context.h
+++ b/src/smf/context.h
@@ -362,7 +362,6 @@ typedef struct smf_sess_s {
 
     /* Paging */
     struct {
-        bool ue_requested_pdu_session_establishment_done;
         char *n1n2message_location;
     } paging;
 
diff --git a/src/smf/gsm-sm.c b/src/smf/gsm-sm.c
index b43bc94..eaade7c 100644
--- a/src/smf/gsm-sm.c
+++ b/src/smf/gsm-sm.c
@@ -35,6 +35,7 @@
 #include "pfcp-path.h"
 #include "ngap-path.h"
 #include "fd-path.h"
+#include "log.h"
 
 static uint8_t gtp_cause_from_diameter(uint8_t gtp_version,
         const uint32_t dia_err, const uint32_t *dia_exp_err)
@@ -640,6 +641,9 @@ void smf_gsm_state_wait_pfcp_establishment(ogs_fsm_t *s, smf_event_t *e)
     ogs_pfcp_message_t *pfcp_message = NULL;
     int rv;
 
+    smf_bearer_t *qos_flow = NULL;
+    char buf[OGS_ADDRSTRLEN];
+
     ogs_assert(s);
     ogs_assert(e);
 
@@ -707,6 +711,13 @@ void smf_gsm_state_wait_pfcp_establishment(ogs_fsm_t *s, smf_event_t *e)
                 pfcp_cause = smf_5gc_n4_handle_session_establishment_response(
                         sess, pfcp_xact,
                         &pfcp_message->pfcp_session_establishment_response);
+                
+                ogs_list_for_each(&sess->bearer_list, qos_flow) {
+                    smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+                        sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+                        qos_flow->dl_far->apply_action);
+                }
+                
                 if (pfcp_cause != OGS_PFCP_CAUSE_REQUEST_ACCEPTED)
                     return;
                 memset(&param, 0, sizeof(param));
diff --git a/src/smf/log.c b/src/smf/log.c
new file mode 100644
index 0000000..5396a6c
--- /dev/null
+++ b/src/smf/log.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2019-2022 by Sukchan Lee <acetcom@gmail.com>
+ *
+ * This file is part of Open5GS.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-12-04 Description: add lgcns custom log
+ */
+
+#include "log.h"
+#include "context.h"
+
+void smf_log_pfcp_message(uint8_t message_type, ogs_sockaddr_t *addr, const char* supi)
+{    
+    char buf[OGS_ADDRSTRLEN];
+
+    switch (message_type) {
+    case OGS_PFCP_ASSOCIATION_SETUP_REQUEST_TYPE:
+        ogs_message("[upf: %s] PFCPAssociationSetupRequest", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_ASSOCIATION_SETUP_RESPONSE_TYPE:
+        ogs_message("[upf: %s] PFCPAssociationSetupResponse", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionEstablishmentRequest", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionEstablishmentResponse", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionModificationRequest", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionModificationResponse", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_REPORT_REQUEST_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionReportRequest", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    case OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE:
+        ogs_message("[%s][upf: %s] PFCPSessionReportResponse", supi ? supi : "imsi-", OGS_ADDR(addr, buf));
+        break;
+    }
+}
+
+void smf_log_session_state(const char *supi, const uint8_t qfi, const char *dnn, const char *ip, ogs_pfcp_apply_action_t apply_action){
+
+    if (apply_action == 0) {
+        ogs_info("[%s][%d][%s][%s] SM_NULL", supi, qfi, dnn, ip);
+    } else if (apply_action & OGS_PFCP_APPLY_ACTION_BUFF) {
+        ogs_info("[%s][%d][%s][%s] SM_BUFFER", supi, qfi, dnn, ip);
+    } else if (apply_action & OGS_PFCP_APPLY_ACTION_FORW) {
+        ogs_info("[%s][%d][%s][%s] SM_FORWARD", supi, qfi, dnn, ip);
+    } 
+
+}
\ No newline at end of file
diff --git a/src/smf/log.h b/src/smf/log.h
new file mode 100644
index 0000000..8a66876
--- /dev/null
+++ b/src/smf/log.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019-2022 by Sukchan Lee <acetcom@gmail.com>
+ *
+ * This file is part of Open5GS.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Modified Date: 2023-12-04 Description: add lgcns custom log
+ */
+
+#ifndef SMF_LOG_H
+#define SMF_LOG_H
+
+#include "ogs-proto.h"
+#include "ogs-core.h"
+#include "ogs-pfcp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void smf_log_pfcp_message(uint8_t message_type, ogs_sockaddr_t *addr, const char* supi);
+
+void smf_log_session_state(const char *supi, const uint8_t qfi, const char *dnn, const char *ip,
+    ogs_pfcp_apply_action_t apply_action);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SMF_LOG_H */
diff --git a/src/smf/meson.build b/src/smf/meson.build
index 12599f3..0ad9f46 100644
--- a/src/smf/meson.build
+++ b/src/smf/meson.build
@@ -67,6 +67,7 @@ libsmf_sources = files('''
     ngap-handler.h
     ngap-path.h
     metrics.h
+    log.h
 
     init.c
     event.c
@@ -106,6 +107,7 @@ libsmf_sources = files('''
     ngap-handler.c
     ngap-path.c
     metrics.c
+    log.c
 '''.split())
 
 libsmf = static_library('smf',
diff --git a/src/smf/n4-handler.c b/src/smf/n4-handler.c
index ef3e2b5..3f59b4a 100644
--- a/src/smf/n4-handler.c
+++ b/src/smf/n4-handler.c
@@ -26,6 +26,7 @@
 #include "sbi-path.h"
 #include "ngap-path.h"
 #include "fd-path.h"
+#include "log.h"
 
 uint8_t gtp_cause_from_pfcp(uint8_t pfcp_cause, uint8_t gtp_version)
 {
@@ -163,6 +164,7 @@ uint8_t smf_5gc_n4_handle_session_establishment_response(
     ogs_assert(rsp);
 
     ogs_debug("Session Establishment Response [5gc]");
+    smf_log_pfcp_message(OGS_PFCP_SESSION_ESTABLISHMENT_RESPONSE_TYPE, &xact->node->addr, sess->smf_ue->supi);
 
     stream = xact->assoc_stream;
     ogs_assert(stream);
@@ -255,6 +257,7 @@ void smf_5gc_n4_handle_session_modification_response(
     OGS_LIST(pdr_to_create_list);
 
     ogs_debug("Session Modification Response [5gc]");
+    smf_log_pfcp_message(OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE, &xact->node->addr, sess->smf_ue->supi);
 
     ogs_assert(xact);
     ogs_assert(rsp);
@@ -401,8 +404,6 @@ void smf_5gc_n4_handle_session_modification_response(
                     sess, stream, OpenAPI_ho_state_COMPLETED);
 
         } else {
-            sess->paging.ue_requested_pdu_session_establishment_done = true;
-
             if (sess->up_cnx_state == OpenAPI_up_cnx_state_ACTIVATING) {
                 sess->up_cnx_state = OpenAPI_up_cnx_state_ACTIVATED;
                 smf_sbi_send_sm_context_updated_data_up_cnx_state(
@@ -1157,6 +1158,7 @@ void smf_n4_handle_session_report_request(
         smf_sess_t *sess, ogs_pfcp_xact_t *pfcp_xact,
         ogs_pfcp_session_report_request_t *pfcp_req)
 {
+    smf_ue_t *smf_ue = NULL;
     smf_bearer_t *qos_flow = NULL;
     smf_bearer_t *bearer = NULL;
     ogs_pfcp_pdr_t *pdr = NULL;
@@ -1193,12 +1195,18 @@ void smf_n4_handle_session_report_request(
     }
 
     ogs_assert(sess);
+    
+    smf_log_pfcp_message(OGS_PFCP_SESSION_REPORT_REQUEST_TYPE, &pfcp_xact->node->addr, sess->smf_ue->supi);
+    
+    smf_ue = sess->smf_ue;
+    ogs_assert(smf_ue);
     report_type.value = pfcp_req->report_type.u8;
 
     if (report_type.downlink_data_report) {
         ogs_pfcp_downlink_data_service_information_t *info = NULL;
         uint8_t paging_policy_indication_value = 0;
         uint8_t qfi = 0;
+        smf_n1_n2_message_transfer_param_t param;
 
         if (pfcp_req->downlink_data_report.presence) {
             if (pfcp_req->downlink_data_report.
@@ -1263,9 +1271,21 @@ void smf_n4_handle_session_report_request(
             return;
         }
 
-        if (sess->paging.ue_requested_pdu_session_establishment_done == true) {
-            smf_n1_n2_message_transfer_param_t param;
-
+        switch (sess->up_cnx_state) {
+        case OpenAPI_up_cnx_state_NULL:
+            /* UE Requested PDU Session is NOT established */
+            break;
+        case OpenAPI_up_cnx_state_ACTIVATED:
+            ogs_error("[%s:%s] PDU Session had already been ACTIVATED",
+                smf_ue->imsi_bcd, sess->session.name);
+            break;
+        case OpenAPI_up_cnx_state_ACTIVATING:
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 1
+            ogs_warn("[%s:%s] UE is being triggering Service Request",
+                smf_ue->imsi_bcd, sess->session.name);
+            break;
+#endif
+        case OpenAPI_up_cnx_state_DEACTIVATED:
             memset(&param, 0, sizeof(param));
             param.state = SMF_NETWORK_TRIGGERED_SERVICE_REQUEST;
             param.n2smbuf =
@@ -1275,6 +1295,14 @@ void smf_n4_handle_session_report_request(
             param.n1n2_failure_txf_notif_uri = true;
 
             smf_namf_comm_send_n1_n2_message_transfer(sess, &param);
+            break;
+        case OpenAPI_up_cnx_state_SUSPENDED:
+            ogs_error("[%s:%s] PDU Session had been SUSPENDED",
+                smf_ue->imsi_bcd, sess->session.name);
+            break;
+        default:
+            ogs_error("Invalid UpCnxState[%d]", sess->up_cnx_state);
+            break;
         }
     }
 
diff --git a/src/smf/npcf-handler.c b/src/smf/npcf-handler.c
index c035346..2633bd2 100644
--- a/src/smf/npcf-handler.c
+++ b/src/smf/npcf-handler.c
@@ -23,6 +23,7 @@
 #include "binding.h"
 
 #include "npcf-handler.h"
+#include "log.h"
 
 static void update_authorized_pcc_rule_and_qos(
         smf_sess_t *sess, OpenAPI_sm_policy_decision_t *SmPolicyDecision)
@@ -632,6 +633,12 @@ bool smf_npcf_smpolicycontrol_handle_create(
     ogs_assert(OGS_OK ==
         smf_5gc_pfcp_send_session_establishment_request(sess, stream));
 
+    ogs_list_for_each(&sess->bearer_list, qos_flow) {
+        smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+            sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf1) : "",
+            qos_flow->dl_far->apply_action);
+    }
+
     return true;
 
 cleanup:
diff --git a/src/smf/pfcp-path.c b/src/smf/pfcp-path.c
index a636f18..a371443 100644
--- a/src/smf/pfcp-path.c
+++ b/src/smf/pfcp-path.c
@@ -19,6 +19,7 @@
 
 #include "sbi-path.h"
 #include "pfcp-path.h"
+#include "log.h"
 
 /* Converts PFCP "Usage Report" "Report Trigger" bitmask to Gy "Reporting-Reason" AVP enum value.
  * PFCP: 3GPP TS 29.244 sec 8.2.41
@@ -351,11 +352,15 @@ int smf_pfcp_send_modify_list(
 
     if (duration) {
         ogs_pfcp_xact_delayed_commit(xact, duration);
-
+        smf_log_pfcp_message(OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE, &xact->node->addr, sess->smf_ue->supi);
         return OGS_OK;
     } else {
         rv = ogs_pfcp_xact_commit(xact);
         ogs_expect(rv == OGS_OK);
+        
+        if (rv == OGS_OK){
+            smf_log_pfcp_message(OGS_PFCP_SESSION_MODIFICATION_REQUEST_TYPE, &xact->node->addr, sess->smf_ue->supi);
+        }
 
         return rv;
     }
@@ -400,6 +405,8 @@ int smf_5gc_pfcp_send_session_establishment_request(
     rv = ogs_pfcp_xact_commit(xact);
     ogs_expect(rv == OGS_OK);
 
+    smf_log_pfcp_message(OGS_PFCP_SESSION_ESTABLISHMENT_REQUEST_TYPE, &xact->node->addr, sess->smf_ue->supi);
+
     return rv;
 }
 
@@ -411,6 +418,9 @@ int smf_5gc_pfcp_send_all_pdr_modification_request(
     ogs_pfcp_xact_t *xact = NULL;
     ogs_pfcp_pdr_t *pdr = NULL;
 
+    char buf[OGS_ADDRSTRLEN];
+    smf_bearer_t *qos_flow = NULL;
+
     ogs_assert(sess);
     if ((flags & OGS_PFCP_MODIFY_ERROR_INDICATION) == 0)
         ogs_assert(stream);
@@ -431,6 +441,12 @@ int smf_5gc_pfcp_send_all_pdr_modification_request(
 
     rv = smf_pfcp_send_modify_list(
             sess, smf_n4_build_pdr_to_modify_list, xact, duration);
+
+    ogs_list_for_each(&sess->bearer_list, qos_flow) {
+        smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+            sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+            qos_flow->dl_far->apply_action);
+    }
     ogs_expect(rv == OGS_OK);
 
     return rv;
@@ -443,6 +459,9 @@ int smf_5gc_pfcp_send_qos_flow_list_modification_request(
     int rv;
     ogs_pfcp_xact_t *xact = NULL;
 
+    char buf[OGS_ADDRSTRLEN];
+    smf_bearer_t *qos_flow = NULL;
+
     ogs_assert(sess);
 
     xact = ogs_pfcp_xact_local_create(sess->pfcp_node, sess_5gc_timeout, sess);
@@ -457,6 +476,14 @@ int smf_5gc_pfcp_send_qos_flow_list_modification_request(
 
     rv = smf_pfcp_send_modify_list(
             sess, smf_n4_build_qos_flow_to_modify_list, xact, duration);
+
+    ogs_list_for_each(&sess->bearer_list, qos_flow) {
+        smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+            sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+            qos_flow->dl_far->apply_action);
+    }
+
+
     ogs_expect(rv == OGS_OK);
 
     return rv;
@@ -555,6 +582,9 @@ int smf_epc_pfcp_send_all_pdr_modification_request(
     ogs_pfcp_xact_t *xact = NULL;
     ogs_pfcp_pdr_t *pdr = NULL;
 
+    char buf[OGS_ADDRSTRLEN];
+    smf_bearer_t *qos_flow = NULL;
+
     ogs_assert(sess);
 
     xact = ogs_pfcp_xact_local_create(sess->pfcp_node, sess_epc_timeout, sess);
@@ -584,6 +614,14 @@ int smf_epc_pfcp_send_all_pdr_modification_request(
 
     rv = smf_pfcp_send_modify_list(
             sess, smf_n4_build_pdr_to_modify_list, xact, 0);
+
+    ogs_list_for_each(&sess->bearer_list, qos_flow) {
+        smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+            sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+            qos_flow->dl_far->apply_action);
+    }
+
+
     ogs_expect(rv == OGS_OK);
 
     return rv;
@@ -596,6 +634,9 @@ int smf_epc_pfcp_send_one_bearer_modification_request(
     int rv;
     ogs_pfcp_xact_t *xact = NULL;
     smf_sess_t *sess = NULL;
+    
+    char buf[OGS_ADDRSTRLEN];
+    smf_bearer_t *qos_flow = NULL;
 
     ogs_assert(bearer);
     sess = bearer->sess;
@@ -621,6 +662,13 @@ int smf_epc_pfcp_send_one_bearer_modification_request(
 
     rv = smf_pfcp_send_modify_list(
             sess, smf_n4_build_qos_flow_to_modify_list, xact, 0);
+
+    ogs_list_for_each(&sess->bearer_list, qos_flow) {
+        smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+            sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+            qos_flow->dl_far->apply_action);
+    }
+
     ogs_expect(rv == OGS_OK);
 
     return rv;
@@ -785,5 +833,9 @@ int smf_pfcp_send_session_report_response(
     rv = ogs_pfcp_xact_commit(xact);
     ogs_expect(rv == OGS_OK);
 
+    if (rv == OGS_OK){
+        smf_log_pfcp_message(OGS_PFCP_SESSION_REPORT_RESPONSE_TYPE, &xact->node->addr, sess->smf_ue->supi);
+    }
+
     return rv;
 }
diff --git a/src/smf/pfcp-sm.c b/src/smf/pfcp-sm.c
index 4dab934..a6b105e 100644
--- a/src/smf/pfcp-sm.c
+++ b/src/smf/pfcp-sm.c
@@ -21,6 +21,7 @@
 #include "pfcp-path.h"
 
 #include "n4-handler.h"
+#include "log.h"
 
 static void reselect_upf(ogs_pfcp_node_t *node);
 static void node_timeout(ogs_pfcp_xact_t *xact, void *data);
@@ -170,6 +171,8 @@ void smf_pfcp_state_associated(ogs_fsm_t *s, smf_event_t *e)
     ogs_sockaddr_t *addr = NULL;
     smf_sess_t *sess = NULL;
 
+    smf_bearer_t *qos_flow = NULL;
+
     ogs_assert(s);
     ogs_assert(e);
 
@@ -315,13 +318,19 @@ void smf_pfcp_state_associated(ogs_fsm_t *s, smf_event_t *e)
         case OGS_PFCP_SESSION_MODIFICATION_RESPONSE_TYPE:
             if (!message->h.seid_presence) ogs_error("No SEID");
 
-            if (xact->epc)
+            if (xact->epc) {
                 smf_epc_n4_handle_session_modification_response(
                     sess, xact, e->gtp2_message,
                     &message->pfcp_session_modification_response);
-            else
+            } else {
                 smf_5gc_n4_handle_session_modification_response(
                     sess, xact, &message->pfcp_session_modification_response);
+                ogs_list_for_each(&sess->bearer_list, qos_flow) {
+                    smf_log_session_state(sess->smf_ue->supi, qos_flow->qfi, sess->session.name,
+                        sess->ipv4 ? OGS_INET_NTOP(&sess->ipv4->addr, buf) : "",
+                        qos_flow->dl_far->apply_action);
+                }
+            }
             break;
 
         case OGS_PFCP_SESSION_DELETION_RESPONSE_TYPE:
diff --git a/tests/registration/auth-test.c b/tests/registration/auth-test.c
index 9ae7a13..72adc77 100644
--- a/tests/registration/auth-test.c
+++ b/tests/registration/auth-test.c
@@ -206,11 +206,360 @@ static void test1_func(abts_case *tc, void *data)
     test_ue_remove(test_ue);
 }
 
+static void test2_func(abts_case *tc, void *data)
+{
+    int rv;
+    ogs_socknode_t *ngap;
+    ogs_socknode_t *gtpu;
+    ogs_pkbuf_t *gmmbuf;
+    ogs_pkbuf_t *gsmbuf;
+    ogs_pkbuf_t *nasbuf;
+    ogs_pkbuf_t *sendbuf;
+    ogs_pkbuf_t *recvbuf;
+    ogs_ngap_message_t message;
+    int i;
+
+    ogs_nas_5gs_mobile_identity_suci_t mobile_identity_suci;
+    test_ue_t *test_ue = NULL;
+    test_sess_t *sess = NULL;
+    test_bearer_t *qos_flow = NULL;
+
+    bson_t *doc = NULL;
+
+    /* Setup Test UE & Session Context */
+    memset(&mobile_identity_suci, 0, sizeof(mobile_identity_suci));
+
+    mobile_identity_suci.h.supi_format = OGS_NAS_5GS_SUPI_FORMAT_IMSI;
+    mobile_identity_suci.h.type = OGS_NAS_5GS_MOBILE_IDENTITY_SUCI;
+    mobile_identity_suci.routing_indicator1 = 0;
+    mobile_identity_suci.routing_indicator2 = 0xf;
+    mobile_identity_suci.routing_indicator3 = 0xf;
+    mobile_identity_suci.routing_indicator4 = 0xf;
+    mobile_identity_suci.protection_scheme_id = OGS_PROTECTION_SCHEME_NULL;
+    mobile_identity_suci.home_network_pki_value = 0;
+
+    test_ue = test_ue_add_by_suci(&mobile_identity_suci, "0000203190");
+    ogs_assert(test_ue);
+
+    test_ue->nr_cgi.cell_id = 0x40001;
+
+    test_ue->nas.registration.tsc = 0;
+    test_ue->nas.registration.ksi = OGS_NAS_KSI_NO_KEY_IS_AVAILABLE;
+    test_ue->nas.registration.follow_on_request = 1;
+    test_ue->nas.registration.value = OGS_NAS_5GS_REGISTRATION_TYPE_INITIAL;
+
+    test_ue->k_string = "465b5ce8b199b49faa5f0a2ee238a6bc";
+    test_ue->opc_string = "e8ed289deba952e4283b54e88e6183ca";
+
+    /* gNB connects to AMF */
+    ngap = testngap_client(AF_INET);
+    ABTS_PTR_NOTNULL(tc, ngap);
+
+    /* gNB connects to UPF */
+    gtpu = test_gtpu_server(1, AF_INET);
+    ABTS_PTR_NOTNULL(tc, gtpu);
+
+    /* Send NG-Setup Reqeust */
+    sendbuf = testngap_build_ng_setup_request(0x4000, 22);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive NG-Setup Response */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /********** Insert Subscriber in Database */
+    doc = test_db_new_simple(test_ue);
+    ABTS_PTR_NOTNULL(tc, doc);
+    ABTS_INT_EQUAL(tc, OGS_OK, test_db_insert_ue(test_ue, doc));
+
+    /* Send Registration request */
+    test_ue->registration_request_param.guti = 1;
+    gmmbuf = testgmm_build_registration_request(test_ue, NULL, false, false);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+
+    test_ue->registration_request_param.gmm_capability = 1;
+    test_ue->registration_request_param.s1_ue_network_capability = 1;
+    test_ue->registration_request_param.requested_nssai = 1;
+    test_ue->registration_request_param.last_visited_registered_tai = 1;
+    test_ue->registration_request_param.ue_usage_setting = 1;
+    nasbuf = testgmm_build_registration_request(test_ue, NULL, false, false);
+    ABTS_PTR_NOTNULL(tc, nasbuf);
+
+    sendbuf = testngap_build_initial_ue_message(test_ue, gmmbuf,
+                NGAP_RRCEstablishmentCause_mo_Signalling, false, true);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Identity request */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send Identity response */
+    gmmbuf = testgmm_build_identity_response(test_ue);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Authentication request */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send Authentication response */
+    gmmbuf = testgmm_build_authentication_response(test_ue);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Security mode command */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send Security mode complete */
+    gmmbuf = testgmm_build_security_mode_complete(test_ue, nasbuf);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive InitialContextSetupRequest +
+     * Registration accept */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+    ABTS_INT_EQUAL(tc,
+            NGAP_ProcedureCode_id_InitialContextSetup,
+            test_ue->ngap_procedure_code);
+
+    /* Send UERadioCapabilityInfoIndication */
+    sendbuf = testngap_build_ue_radio_capability_info_indication(test_ue);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send InitialContextSetupResponse */
+    sendbuf = testngap_build_initial_context_setup_response(test_ue, false);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send Registration complete */
+    gmmbuf = testgmm_build_registration_complete(test_ue);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Configuration update command */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send PDU session establishment request */
+    sess = test_sess_add_by_dnn_and_psi(test_ue, "internet", 5);
+    ogs_assert(sess);
+
+    sess->ul_nas_transport_param.request_type =
+        OGS_NAS_5GS_REQUEST_TYPE_INITIAL;
+    sess->ul_nas_transport_param.dnn = 1;
+    sess->ul_nas_transport_param.s_nssai = 0;
+
+    sess->pdu_session_establishment_param.ssc_mode = 1;
+    sess->pdu_session_establishment_param.epco = 1;
+
+    gsmbuf = testgsm_build_pdu_session_establishment_request(sess);
+    ABTS_PTR_NOTNULL(tc, gsmbuf);
+    gmmbuf = testgmm_build_ul_nas_transport(sess,
+            OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, gsmbuf);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive PDUSessionResourceSetupRequest +
+     * DL NAS transport +
+     * PDU session establishment accept */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+    ABTS_INT_EQUAL(tc,
+            NGAP_ProcedureCode_id_PDUSessionResourceSetup,
+            test_ue->ngap_procedure_code);
+
+    /* Send PDUSessionResourceSetupResponse */
+    sendbuf = testngap_sess_build_pdu_session_resource_setup_response(sess);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send UEContextReleaseRequest */
+    sendbuf = testngap_build_ue_context_release_request(test_ue,
+            NGAP_Cause_PR_radioNetwork, NGAP_CauseRadioNetwork_user_inactivity,
+            true);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive UEContextReleaseCommand */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+    ABTS_INT_EQUAL(tc,
+            NGAP_ProcedureCode_id_UEContextRelease,
+            test_ue->ngap_procedure_code);
+
+    /* Send UEContextReleaseComplete */
+    sendbuf = testngap_build_ue_context_release_complete(test_ue);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send Registration request
+     * - Update Registration request type
+     * - Uplink Data Status */
+    memset(&test_ue->registration_request_param, 0,
+            sizeof(test_ue->registration_request_param));
+    test_ue->nas.registration.value =
+        OGS_NAS_5GS_REGISTRATION_TYPE_MOBILITY_UPDATING;
+
+    test_ue->registration_request_param.uplink_data_status = 1;
+    test_ue->registration_request_param.psimask.uplink_data_status =
+        1 << sess->psi;
+    nasbuf = testgmm_build_registration_request(test_ue, NULL, false, false);
+    ABTS_PTR_NOTNULL(tc, nasbuf);
+
+    memset(&test_ue->registration_request_param, 0,
+            sizeof(test_ue->registration_request_param));
+    test_ue->registration_request_param.guti = 1;
+    gmmbuf = testgmm_build_registration_request(test_ue, NULL, true, false);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+
+    sendbuf = testngap_build_initial_ue_message(test_ue, gmmbuf,
+                NGAP_RRCEstablishmentCause_mo_Signalling, true, true);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+
+    /* Overwrite Message authentcation code for mac_failed = 1 */
+    memset(sendbuf->data + 20, 0, 4);
+
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Authentication request */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send Authentication response */
+    gmmbuf = testgmm_build_authentication_response(test_ue);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Security mode command */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send Security mode complete */
+    gmmbuf = testgmm_build_security_mode_complete(test_ue, nasbuf);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive InitialContextSetupRequest +
+     * Registration accept */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+    ABTS_INT_EQUAL(tc,
+            NGAP_ProcedureCode_id_InitialContextSetup,
+            test_ue->ngap_procedure_code);
+
+    /* Send UERadioCapabilityInfoIndication */
+    sendbuf = testngap_build_ue_radio_capability_info_indication(test_ue);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send InitialContextSetupResponse */
+    sendbuf = testngap_build_initial_context_setup_response(test_ue, false);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Send Registration complete */
+    gmmbuf = testgmm_build_registration_complete(test_ue);
+    ABTS_PTR_NOTNULL(tc, gmmbuf);
+    sendbuf = testngap_build_uplink_nas_transport(test_ue, gmmbuf);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive Configuration update command */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+
+    /* Send UEContextReleaseRequest */
+    sendbuf = testngap_build_ue_context_release_request(test_ue,
+            NGAP_Cause_PR_radioNetwork, NGAP_CauseRadioNetwork_user_inactivity,
+            true);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    /* Receive UEContextReleaseCommand */
+    recvbuf = testgnb_ngap_read(ngap);
+    ABTS_PTR_NOTNULL(tc, recvbuf);
+    testngap_recv(test_ue, recvbuf);
+    ABTS_INT_EQUAL(tc,
+            NGAP_ProcedureCode_id_UEContextRelease,
+            test_ue->ngap_procedure_code);
+
+    /* Send UEContextReleaseComplete */
+    sendbuf = testngap_build_ue_context_release_complete(test_ue);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+
+    ogs_msleep(300);
+
+    /********** Remove Subscriber in Database */
+    ABTS_INT_EQUAL(tc, OGS_OK, test_db_remove_ue(test_ue));
+
+    /* gNB disonncect from UPF */
+    testgnb_gtpu_close(gtpu);
+
+    /* gNB disonncect from AMF */
+    testgnb_ngap_close(ngap);
+
+    /* Clear Test UE Context */
+    test_ue_remove(test_ue);
+}
+
 abts_suite *test_auth(abts_suite *suite)
 {
     suite = ADD_SUITE(suite)
 
     abts_run_test(suite, test1_func, NULL);
+    abts_run_test(suite, test2_func, NULL);
 
     return suite;
 }
diff --git a/tests/registration/paging-test.c b/tests/registration/paging-test.c
index 7d930e2..d601095 100644
--- a/tests/registration/paging-test.c
+++ b/tests/registration/paging-test.c
@@ -858,6 +858,7 @@ static void cm_connected_paging_func(abts_case *tc, void *data)
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Receive PDUSessionResourceSetupRequest +
      * DL NAS transport +
      * PDU session establishment accept */
@@ -867,12 +868,14 @@ static void cm_connected_paging_func(abts_case *tc, void *data)
     ABTS_INT_EQUAL(tc,
             NGAP_ProcedureCode_id_PDUSessionResourceSetup,
             test_ue->ngap_procedure_code);
+#endif
 
     /* Receive GTP-U ICMP Packet */
     recvbuf = testgnb_gtpu_read(gtpu);
     ABTS_PTR_NOTNULL(tc, recvbuf);
     ogs_pkbuf_free(recvbuf);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Send PDUSessionResourceSetupResponse(Unsuccessful) */
     sendbuf = testngap_sess_build_pdu_session_resource_failed_to_setup(
             sess,
@@ -881,6 +884,7 @@ static void cm_connected_paging_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, sendbuf);
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
 
     /* Send GTP-U ICMP Packet */
     rv = test_gtpu_send_ping(gtpu, qos_flow, TEST_PING_IPV4);
@@ -891,6 +895,16 @@ static void cm_connected_paging_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, recvbuf);
     ogs_pkbuf_free(recvbuf);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 1
+    /* Send UEContextReleaseRequest */
+    sendbuf = testngap_build_ue_context_release_request(test_ue,
+            NGAP_Cause_PR_radioNetwork, NGAP_CauseRadioNetwork_user_inactivity,
+            true);
+    ABTS_PTR_NOTNULL(tc, sendbuf);
+    rv = testgnb_ngap_send(ngap, sendbuf);
+    ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
+
     /* Receive UEContextReleaseCommand */
     recvbuf = testgnb_ngap_read(ngap);
     ABTS_PTR_NOTNULL(tc, recvbuf);
@@ -1867,6 +1881,7 @@ static void vonr_qos_flow_test1_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, recvbuf);
     ogs_pkbuf_free(recvbuf);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Receive PDUSessionResourceSetupRequest */
     recvbuf = testgnb_ngap_read(ngap);
     ABTS_PTR_NOTNULL(tc, recvbuf);
@@ -1880,6 +1895,7 @@ static void vonr_qos_flow_test1_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, sendbuf);
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
 
     /* Send GTP-U ICMP Packet */
     rv = test_gtpu_send_ping(gtpu, qos_flow, TEST_PING_IPV4);
@@ -2304,6 +2320,7 @@ static void vonr_session_test2_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, recvbuf);
     ogs_pkbuf_free(recvbuf);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Receive PDUSessionResourceSetupRequest */
     recvbuf = testgnb_ngap_read(ngap);
     ABTS_PTR_NOTNULL(tc, recvbuf);
@@ -2317,6 +2334,7 @@ static void vonr_session_test2_func(abts_case *tc, void *data)
     ABTS_PTR_NOTNULL(tc, sendbuf);
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
 
     /* Send GTP-U ICMP Packet */
     rv = test_gtpu_send_ping(gtpu, qos_flow, TEST_PING_IPV4);
@@ -2742,6 +2760,7 @@ static void registration_ue_context_test4_func(abts_case *tc, void *data)
     rv = test_gtpu_send_ping(gtpu, qos_flow, TEST_PING_IPV4);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Receive PDUSessionResourceSetupRequest */
     recvbuf = testgnb_ngap_read(ngap);
     ABTS_PTR_NOTNULL(tc, recvbuf);
@@ -2749,6 +2768,7 @@ static void registration_ue_context_test4_func(abts_case *tc, void *data)
     ABTS_INT_EQUAL(tc,
             NGAP_ProcedureCode_id_PDUSessionResourceSetup,
             test_ue->ngap_procedure_code);
+#endif
 
     /* Send InitialContextSetupResponse */
     sendbuf = testngap_build_initial_context_setup_response(test_ue, true);
@@ -2756,11 +2776,13 @@ static void registration_ue_context_test4_func(abts_case *tc, void *data)
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Send PDUSessionResourceSetupResponse */
     sendbuf = testngap_ue_build_pdu_session_resource_setup_response(test_ue);
     ABTS_PTR_NOTNULL(tc, sendbuf);
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
 
     /* Receive GTP-U ICMP Packet */
     recvbuf = testgnb_gtpu_read(gtpu);
@@ -3171,6 +3193,7 @@ static void registration_idle_test1_func(abts_case *tc, void *data)
     rv = test_gtpu_send_ping(gtpu, qos_flow, TEST_PING_IPV4);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Receive PDUSessionResourceSetupRequest */
     recvbuf = testgnb_ngap_read(ngap);
     ABTS_PTR_NOTNULL(tc, recvbuf);
@@ -3178,6 +3201,7 @@ static void registration_idle_test1_func(abts_case *tc, void *data)
     ABTS_INT_EQUAL(tc,
             NGAP_ProcedureCode_id_PDUSessionResourceSetup,
             test_ue->ngap_procedure_code);
+#endif
 
     /* Send InitialContextSetupResponse */
     sendbuf = testngap_build_initial_context_setup_response(test_ue, true);
@@ -3185,11 +3209,13 @@ static void registration_idle_test1_func(abts_case *tc, void *data)
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
 
+#if OGS_SBI_DISABLE_NETWORK_SERVICE_REQUEST_WHILE_ACTIVATING == 0
     /* Send PDUSessionResourceSetupResponse */
     sendbuf = testngap_sess_build_pdu_session_resource_setup_response(sess);
     ABTS_PTR_NOTNULL(tc, sendbuf);
     rv = testgnb_ngap_send(ngap, sendbuf);
     ABTS_INT_EQUAL(tc, OGS_OK, rv);
+#endif
 
     /* Receive GTP-U ICMP Packet */
     recvbuf = testgnb_gtpu_read(gtpu);
